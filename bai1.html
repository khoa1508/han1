<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>√în t·∫≠p Ti·∫øng Trung Vui (Click-to-Match)</title>
    
    <script>
        // C·∫§U H√åNH: T√™n mi·ªÅn h·ª£p l·ªá (B·ªè http/https, ch·ªâ l·∫•y domain)
        const DOMAIN_HOP_LE = "khoa1508.github.io"; 
        
        // Link trang ch·ªß ƒë·ªÉ ƒë√° v·ªÅ khi b·ªã ch·∫∑n
        const LINK_TRANG_CHU = "https://khoa1508.github.io/portal/portal2"; // H√£y ƒë·∫£m b·∫£o link n√†y ƒë√∫ng

        function kiemTraTruyCap() {
            const nguonTruyCap = document.referrer;
            
            // Debug: B·∫≠t d√≤ng n√†y l√™n n·∫øu mu·ªën xem ngu·ªìn (F12)
            // console.log("Ngu·ªìn truy c·∫≠p:", nguonTruyCap);

            // LOGIC: 
            // 1. N·∫øu kh√¥ng c√≥ ngu·ªìn (Copy link paste th·∫≥ng) -> CH·∫∂N
            // 2. N·∫øu ngu·ªìn kh√¥ng ch·ª©a "khoa1508.github.io" -> CH·∫∂N
            if (!nguonTruyCap || nguonTruyCap.indexOf(DOMAIN_HOP_LE) === -1) {
                alert("‚ö†Ô∏è Truy c·∫≠p b·ªã t·ª´ ch·ªëi!\nB·∫°n ph·∫£i m·ªü b√†i t·∫≠p n√†y t·ª´ Trang Ch·ªß c·ªßa DDK Chinese.");
                window.location.href = LINK_TRANG_CHU;
                
                // X√≥a tr·∫Øng m√†n h√¨nh ƒë·ªÉ b·∫£o m·∫≠t n·ªôi dung
                document.write('<div style="height:100vh;display:flex;justify-content:center;align-items:center;font-family:sans-serif;"><h1>‚è≥ ƒêang chuy·ªÉn h∆∞·ªõng v·ªÅ trang ch·ªß...</h1></div>');
                return false;
            }
            return true; // Cho ph√©p v√†o
        }
        
        // Ch·∫°y ngay l·∫≠p t·ª©c
        kiemTraTruyCap();
    </script>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; display: flex; flex-direction: column; align-items: center; background-color: #f4f8fb; color: #333; padding-bottom: 50px; margin: 0; }
        h1, h2 { color: #004A99; text-align: center; }
        h2 { margin-bottom: 10px; }
        
        /* Game Container */
        .game-container { background-color: #fff; padding: 25px; border-radius: 16px; box-shadow: 0 10px 30px rgba(0,0,0,0.08); margin-top: 30px; width: 90%; max-width: 900px; border: 1px solid #e0eafc; }
        
        /* Info Bar */
        .game-info { display: flex; justify-content: space-between; align-items: center; margin-bottom: 25px; padding: 15px; background: #f8f9fa; border-radius: 12px; border: 1px solid #eee; flex-wrap: wrap; gap: 10px; }
        .game-info p { margin: 0; font-weight: 600; color: #55606B; }
        .game-info span { color: #FF8C00; font-weight: 700; }
        
        /* Buttons */
        button { font-family: 'Inter', sans-serif; cursor: pointer; border: none; outline: none; transition: all 0.2s ease; }
        #hint-button, #next-part-button, #restart-button, #next-stage1-button { padding: 10px 20px; font-size: 0.95em; font-weight: 600; background-color: #28a745; color: white; border-radius: 8px; box-shadow: 0 4px 6px rgba(40, 167, 69, 0.2); }
        #hint-button:hover, #next-part-button:hover, #restart-button:hover, #next-stage1-button:hover { background-color: #218838; transform: translateY(-1px); }
        #hint-button:disabled { background-color: #ccc; cursor: not-allowed; transform: none; box-shadow: none; }
        
        /* Sections */
        .game-part { margin-top: 10px; text-align: center; }
        .stage-info { font-size: 1.1em; font-weight: bold; color: #004A99; margin-bottom: 5px; }
        .instructions { color: #6c757d; font-style: italic; margin-bottom: 20px; }

        /* === PART 1: MEMORY GAME === */
        .memory-game-grid { display: grid; gap: 12px; perspective: 1000px; justify-content: center; max-width: 600px; margin: 0 auto; }
        .memory-card { background-color: transparent; height: 90px; width: 90px; border-radius: 10px; cursor: pointer; position: relative; transform-style: preserve-3d; transition: transform 0.5s; }
        .memory-card .front-face, .memory-card .back-face { position: absolute; width: 100%; height: 100%; backface-visibility: hidden; display: flex; justify-content: center; align-items: center; border-radius: 10px; padding: 5px; box-sizing: border-box; overflow-wrap: break-word; text-align: center; box-shadow: 0 4px 8px rgba(0,0,0,0.1); }
        
        /* M·∫∑t tr∆∞·ªõc (Ch·ªØ/Pinyin) */
        .memory-card .front-face { background-color: #fff; color: #333; transform: rotateY(180deg); border: 2px solid #e0eafc; font-weight: 600; font-size: 1.2em; }
        /* M·∫∑t sau (D·∫•u h·ªèi) */
        .memory-card .back-face { background-color: #004A99; color: white; font-size: 2.5em; font-weight: 700; }
        
        .memory-card.flip { transform: rotateY(180deg); }
        .memory-card.matched { cursor: default; }
        .memory-card.matched .front-face { background-color: #d4edda; color: #155724; border-color: #c3e6cb; }

        /* === PART 2: CLICK-TO-MATCH === */
        .click-match-container { display: flex; flex-direction: column; gap: 20px; margin-top: 20px; }
        @media (min-width: 768px) { 
            .click-match-container { flex-direction: row; justify-content: space-between; gap: 40px; } 
            .item-column { width: 48%; }
        }
        .item-column { background-color: #f8f9fa; border: 1px solid #e9ecef; padding: 20px; border-radius: 12px; }
        .item-column h3 { margin-top: 0; text-align: center; color: #495057; font-size: 1.1em; border-bottom: 2px solid #dee2e6; padding-bottom: 10px; margin-bottom: 20px; }

        .word-item, .meaning-item { background-color: #fff; border: 2px solid #e9ecef; padding: 15px; margin-bottom: 12px; border-radius: 10px; cursor: pointer; text-align: center; transition: all 0.2s; box-shadow: 0 2px 4px rgba(0,0,0,0.02); }
        .word-item:hover, .meaning-item:hover { border-color: #004A99; transform: translateY(-2px); box-shadow: 0 4px 8px rgba(0,0,0,0.1); }
        
        .word-item .hanzi { font-size: 1.8em; display: block; color: #212529; font-weight: bold; margin-bottom: 4px; }
        .word-item .pinyin { font-size: 0.9em; color: #868e96; }
        .meaning-item { font-size: 1.1em; color: #343a40; font-weight: 500; min-height: 70px; display: flex; align-items: center; justify-content: center; }

        /* States for Part 2 */
        .selected { border-color: #FF8C00 !important; background-color: #FFF4E6 !important; box-shadow: 0 0 0 3px rgba(255, 140, 0, 0.2); }
        .matched { background-color: #d4edda !important; border-color: #28a745 !important; color: #155724 !important; opacity: 0.6; cursor: default; transform: none !important; }
        .incorrect-shake { animation: shake 0.4s cubic-bezier(.36,.07,.19,.97) both; background-color: #f8d7da !important; border-color: #dc3545 !important; }
        @keyframes shake { 10%, 90% { transform: translate3d(-1px, 0, 0); } 20%, 80% { transform: translate3d(2px, 0, 0); } 30%, 50%, 70% { transform: translate3d(-4px, 0, 0); } 40%, 60% { transform: translate3d(4px, 0, 0); } }

        /* Summary */
        #summary { padding: 40px 20px; }
        #summary p { font-size: 1.2em; margin: 15px 0; }
        #summary button { background-color: #FF8C00; font-size: 1.1em; padding: 12px 30px; margin-top: 20px; }
        #summary button:hover { background-color: #e07b00; }
    </style>
</head>
<body>

    <div id="main-content">
        <h1>G√≥c √în T·∫≠p Ti·∫øng Trung DDK</h1>

        <div class="game-container">
            <div class="game-info">
                <p>‚è±Ô∏è Th·ªùi gian: <span id="timer">00:00</span></p>
                <div>
                    <button id="hint-button">üí° G·ª£i √Ω</button>
                    <span style="font-size: 0.9em; margin-left: 5px; color:#aaa;">(C√≤n: <span id="hints-left" style="color:#FF8C00">3</span>)</span>
                </div>
            </div>

            <div id="part1" class="game-part">
                <h2>Ph·∫ßn 1: L·∫≠t th·∫ª t√¨m c·∫∑p</h2>
                <p class="stage-info">M√†n: <span id="stage-display">1/3</span></p>
                <p class="instructions">L·∫≠t 2 th·∫ª ƒë·ªÉ t√¨m c·∫∑p Ch·ªØ H√°n & Pinyin gi·ªëng nhau!</p>
                <div id="memory-game" class="memory-game-grid"></div>
                <button id="next-stage1-button" style="display: none; margin-top: 20px;">Ti·∫øp t·ª•c m√†n sau ‚û°Ô∏è</button>
                <button id="next-part-button" style="display: none; margin-top: 20px;">üéâ Qua Ph·∫ßn 2</button>
            </div>

            <div id="part2" class="game-part" style="display: none;">
                <h2>Ph·∫ßn 2: N·ªëi t·ª´ v·ªõi nghƒ©a</h2>
                <p class="instructions">Ch·ªçn Ch·ªØ H√°n tr∆∞·ªõc, sau ƒë√≥ ch·ªçn Nghƒ©a Ti·∫øng Vi·ªát t∆∞∆°ng ·ª©ng.</p>
                <div class="click-match-container">
                    <div id="word-items" class="item-column">
                        <h3>Ch·ªØ H√°n - Pinyin</h3>
                    </div>
                    <div id="meaning-items" class="item-column">
                        <h3>Nghƒ©a Ti·∫øng Vi·ªát</h3>
                    </div>
                </div>
            </div>

            <div id="summary" class="game-part" style="display: none;">
                 <h2>üèÜ Ho√†n th√†nh xu·∫•t s·∫Øc!</h2>
                 <p>B·∫°n ƒë√£ chinh ph·ª•c b√†i h·ªçc n√†y.</p>
                 <p>Th·ªùi gian: <span id="final-time"></span></p>
                 <p>G·ª£i √Ω ƒë√£ d√πng: <span id="hints-used"></span></p>
                 <button id="restart-button">üîÑ Ch∆°i l·∫°i t·ª´ ƒë·∫ßu</button>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // ---- DATA INPUT ----
            const allPart1DataStr = "‰Ω†n«ê Â•Ωh«éo ‰∏Äyƒ´ ‰∫îw«î ÂÖ´bƒÅ Â§ßd√† ‰∏çb√π Âè£k«íu ÁôΩb√°i Â•≥n«ö È©¨m«é Êàëw«í ‰Ω†n«ê Áà±√†i";
            const part2DataStr = "‰Ω†n«êB·∫°n Â•Ωh«éoT·ªët ‰∏Äyƒ´M·ªôt ‰∫îw«îNƒÉm ÂÖ´bƒÅT√°m Â§ßd√†L·ªõn ‰∏çb√πKh√¥ng Âè£k«íuMi·ªáng ÁôΩb√°iTr·∫Øng Â•≥n«öN·ªØ È©¨m«éNg·ª±a Êàëw«íT√¥i Áà±√†iY√™u";

            // ---- PARSE DATA ----
            const allPart1Pairs = parseAllPart1Data(allPart1DataStr);
            const part1StagesDataArrays = splitIntoStages(allPart1Pairs, [5, 5, 4]);
            const initialHints = 3;

            // ---- DOM ELEMENTS ----
            const memoryGameContainer = document.getElementById('memory-game');
            const nextPartButton = document.getElementById('next-part-button');
            const part1Element = document.getElementById('part1');
            const part2Element = document.getElementById('part2');
            const wordItemsContainer = document.getElementById('word-items');
            const meaningItemsContainer = document.getElementById('meaning-items');
            const timerElement = document.getElementById('timer');
            const hintButton = document.getElementById('hint-button');
            const hintsLeftElement = document.getElementById('hints-left');
            const summaryElement = document.getElementById('summary');
            const finalTimeElement = document.getElementById('final-time');
            const hintsUsedElement = document.getElementById('hints-used');
            const restartButton = document.getElementById('restart-button');
            const stageDisplayElement = document.getElementById('stage-display');
            const nextStage1Button = document.getElementById('next-stage1-button');

            // ---- GAME STATE ----
            let part1Stage = 1; 
            const totalPart1Stages = part1StagesDataArrays.length; 
            let currentStagePairsData = []; 
            let totalPairsCurrentStage = 0;
            let part2ItemsData = []; 
            let flippedCards = []; 
            let matchedPairs = 0; 
            let lockBoard = false; 
            let timerInterval; 
            let seconds = 0;
            let hintsRemaining = initialHints; 
            let hintsUsedCount = 0; 
            let gameStarted = false; 
            let part1Completed = false; 
            let part2Started = false;
            let part2CorrectMatches = 0; 
            let totalItemsPart2 = 0;
            let selectedWordItem = null; 

            // =================== HELPERS ===================
            function parseAllPart1Data(dataStr) { 
                const items = dataStr.trim().split(/\s+/); 
                const pairs = []; 
                let id=0; 
                items.forEach(item => { 
                    const m = item.match(/^([\u4e00-\u9fa5]+)([a-zA-Z√º√úƒÅ√°«é√†ƒì√©ƒõ√®ƒ´√≠«ê√¨≈ç√≥«í√≤≈´√∫«î√π\d]+)$/u); 
                    if(m) pairs.push({ h: m[1], p: m[2], id: `p${id++}`}); 
                }); 
                return pairs; 
            }
            function splitIntoStages(allPairs, stageSizes) { 
                const stages = []; let idx=0; 
                for(const size of stageSizes){ 
                    const s=allPairs.slice(idx, idx + size); 
                    if(s.length>0) stages.push(s); 
                    idx+=size; 
                } 
                if(idx<allPairs.length){ 
                    const r=allPairs.slice(idx); 
                    if(stages.length>0) stages[stages.length-1].push(...r); else stages.push(r); 
                } 
                return stages; 
            }
            function createCardsFromPairs(pairDataArray) { 
                const cards = []; 
                pairDataArray.forEach(p => { 
                    cards.push({ t:'hanzi', v:p.h, pId:p.id }); 
                    cards.push({ t:'pinyin', v:p.p, pId:p.id }); 
                }); 
                return cards; 
            }
            function shuffleArray(array) { 
                for (let i = array.length - 1; i > 0; i--) { 
                    const j = Math.floor(Math.random() * (i + 1)); 
                    [array[i], array[j]] = [array[j], array[i]]; 
                } 
            }

            // =================== PART 1 FUNCTIONS ===================
            function setupPart1Stage(stageNum) { 
                part1Stage=stageNum; 
                if(part1Stage > totalPart1Stages || part1Stage<1) return;
                stageDisplayElement.textContent=`${part1Stage}/${totalPart1Stages}`; 
                memoryGameContainer.innerHTML=''; 
                matchedPairs=0; lockBoard=false; flippedCards=[];
                currentStagePairsData = part1StagesDataArrays[part1Stage-1]||[]; 
                totalPairsCurrentStage = currentStagePairsData.length;
                if(totalPairsCurrentStage===0){ goToPart2(); return; }
                const currentStageCards = createCardsFromPairs(currentStagePairsData); 
                shuffleArray(currentStageCards);
                const numCards = currentStageCards.length; 
                let cols=Math.ceil(Math.sqrt(numCards)); 
                cols=Math.min(cols,5); 
                memoryGameContainer.style.gridTemplateColumns=`repeat(${cols}, minmax(80px, 1fr))`;
                currentStageCards.forEach(d => { 
                    const c=document.createElement('div'); c.className='memory-card'; 
                    c.dataset.pairId=d.pId; c.dataset.type=d.t; c.dataset.value=d.v; 
                    c.innerHTML=`<div class="front-face">${d.v}</div><div class="back-face">?</div>`; 
                    c.addEventListener('click',handleCardFlip); 
                    memoryGameContainer.appendChild(c); 
                }); 
                nextStage1Button.style.display='none'; 
                nextPartButton.style.display='none'; 
                hintButton.style.display='inline-block'; 
                hintButton.disabled = hintsRemaining<=0;
            }
            function handleCardFlip() { 
                if(part1Completed||lockBoard||this.classList.contains('flip')||this.classList.contains('matched')) return; 
                if(!gameStarted){startGameTimer();gameStarted=true;} 
                this.classList.add('flip'); 
                flippedCards.push(this); 
                if(flippedCards.length===2){lockBoard=true;checkForMatch();} 
            }
            function checkForMatch() { 
                const [c1,c2]=flippedCards; 
                const isMatch=c1.dataset.pairId===c2.dataset.pairId; 
                if(isMatch) disableCards(); else unflipCards(); 
            }
            function disableCards() { 
                flippedCards.forEach(c=>{c.classList.add('matched','flip');}); 
                matchedPairs++; resetBoardState(); 
                if(matchedPairs===totalPairsCurrentStage){ 
                    setTimeout(()=>{ 
                        hintButton.style.display='none'; 
                        if(part1Stage<totalPart1Stages) nextStage1Button.style.display='inline-block'; 
                        else {part1Completed=true; nextPartButton.style.display='inline-block';} 
                    }, 500); 
                } 
            }
            function unflipCards() { 
                setTimeout(()=>{ 
                    flippedCards.forEach(c=>{if(!c.classList.contains('matched')) c.classList.remove('flip');}); 
                    resetBoardState(); 
                }, 1000); 
            }
            function resetBoardState() { flippedCards=[]; lockBoard=false; }

            // =================== PART 2 FUNCTIONS ===================
            function parsePart2DataRevised(dataStr) {
                const items = dataStr.trim().split(/\s+/); const parsedItems = []; let uniqueIdCounter = 0;
                items.forEach(item => {
                    let hanzi='', pinyin='', meaning='', pinyinStartIndex = item.search(/[a-zA-Z√º√úƒÅ√°«é√†ƒì√©ƒõ√®ƒ´√≠«ê√¨≈ç√≥«í√≤≈´√∫«î√π]/u);
                    if (pinyinStartIndex === -1) return;
                    hanzi = item.substring(0, pinyinStartIndex);
                    let meaningStartIndex = -1;
                    for (let i = pinyinStartIndex; i < item.length; i++) { if (item[i].match(/[a-zA-Z√Ä√Å√Ç√£√à√â√ä√å√ç√í√ì√î√ï√ô√ö√ùƒÇƒêƒ®≈®∆†∆Ø·∫†·∫¢·∫§·∫¶·∫®·∫™·∫¨·∫Æ·∫∞·∫≤·∫¥·∫∂·∫∏·∫∫·∫º·∫æ·ªÄ·ªÇ·ªÑ·ªÜ·ªà·ªä·ªå·ªé·ªê·ªí·ªî·ªñ·ªò·ªö·ªú·ªû·ª†·ª¢·ª§·ª¶·ª®·ª™·ª¨·ªÆ·ª∞·ª≤·ª¥·ª∂·ª∏]/iu) && item[i] === item[i].toUpperCase() && item[i] !== item[i].toLowerCase()) { meaningStartIndex = i; break; } }
                    if (meaningStartIndex === -1) { for (let i = pinyinStartIndex; i < item.length; i++) { if (item[i].match(/[√†√°√¢√£√®√©√™√¨√≠√≤√≥√¥√µ√π√∫√ΩƒÉƒëƒ©≈©∆°∆∞·∫°·∫£·∫•·∫ß·∫©·∫´·∫≠·∫Ø·∫±·∫≥·∫µ·∫∑·∫π·∫ª·∫Ω·∫ø·ªÅ·ªÉ·ªÖ·ªá·ªâ·ªã·ªç·ªè·ªë·ªì·ªï·ªó·ªô·ªõ·ªù·ªü·ª°·ª£·ª•·ªß·ª©·ª´·ª≠·ªØ·ª±·ª≥·ªµ·ª∑·ªπ]/iu)) { if (i > pinyinStartIndex && item[i-1].match(/[a-zA-Z√º√úƒÅ√°«é√†ƒì√©ƒõ√®ƒ´√≠«ê√¨≈ç√≥«í√≤≈´√∫«î√π\d]/u)) { meaningStartIndex = i; break; } } } }
                    if (meaningStartIndex === -1 || meaningStartIndex <= pinyinStartIndex) return;
                    pinyin = item.substring(pinyinStartIndex, meaningStartIndex); meaning = item.substring(meaningStartIndex);
                    if (hanzi && pinyin && meaning) parsedItems.push({ id: `item-${uniqueIdCounter++}`, hanzi, pinyin, meaning });
                });
                totalItemsPart2 = parsedItems.length;
                return parsedItems;
            }

            function setupPart2() {
                part2ItemsData = parsePart2DataRevised(part2DataStr);
                wordItemsContainer.innerHTML = '<h3>Ch·ªØ H√°n - Pinyin</h3>'; 
                meaningItemsContainer.innerHTML = '<h3>Nghƒ©a Ti·∫øng Vi·ªát</h3>'; 
                part2CorrectMatches = 0; selectedWordItem = null;
                const meaningElements = []; 
                part2ItemsData.forEach(item => {
                    const meaningDiv = document.createElement('div');
                    meaningDiv.classList.add('meaning-item');
                    meaningDiv.textContent = item.meaning;
                    meaningDiv.dataset.meaning = item.meaning;
                    meaningDiv.addEventListener('click', handleMeaningItemClick);
                    meaningElements.push(meaningDiv);
                });
                shuffleArray(meaningElements);
                meaningElements.forEach(el => meaningItemsContainer.appendChild(el));
                const wordElements = []; 
                part2ItemsData.forEach(item => {
                    const wordDiv = document.createElement('div');
                    wordDiv.classList.add('word-item');
                    wordDiv.dataset.meaning = item.meaning;
                    wordDiv.innerHTML = `<span class="hanzi">${item.hanzi}</span><span class="pinyin">${item.pinyin}</span>`;
                    wordDiv.addEventListener('click', handleWordItemClick);
                    wordElements.push(wordDiv);
                });
                shuffleArray(wordElements);
                wordElements.forEach(el => wordItemsContainer.appendChild(el));
                part2Started = true;
                hintButton.style.display = 'inline-block';
                hintButton.disabled = hintsRemaining <= 0;
            }

            function handleWordItemClick() {
                if (this.classList.contains('matched')) return;
                if (selectedWordItem) selectedWordItem.classList.remove('selected');
                if (selectedWordItem === this) selectedWordItem = null;
                else { this.classList.add('selected'); selectedWordItem = this; }
            }

            function handleMeaningItemClick() {
                if (this.classList.contains('matched') || !selectedWordItem) return;
                const clickedMeaningItem = this;
                const targetMeaning = clickedMeaningItem.dataset.meaning;
                const selectedMeaning = selectedWordItem.dataset.meaning;
                selectedWordItem.classList.remove('selected');

                if (targetMeaning === selectedMeaning) {
                    clickedMeaningItem.classList.add('matched');
                    selectedWordItem.classList.add('matched');
                    part2CorrectMatches++;
                    selectedWordItem = null;
                    if (part2CorrectMatches === totalItemsPart2) {
                        stopGameTimer(); showSummary();
                    }
                } else {
                    clickedMeaningItem.classList.add('incorrect-shake');
                    selectedWordItem.classList.add('incorrect-shake');
                    setTimeout(() => {
                        clickedMeaningItem.classList.remove('incorrect-shake');
                        selectedWordItem.classList.remove('incorrect-shake');
                        selectedWordItem = null;
                    }, 400);
                }
            }

            // =================== COMMON FEATURES ===================
            function startGameTimer() { clearInterval(timerInterval); seconds = 0; timerElement.textContent = formatTime(seconds); timerInterval = setInterval(() => { seconds++; timerElement.textContent = formatTime(seconds); }, 1000); }
            function stopGameTimer() { clearInterval(timerInterval); }
            function formatTime(totalSeconds) { const minutes = Math.floor(totalSeconds / 60); const secs = totalSeconds % 60; return `${String(minutes).padStart(2, '0')}:${String(secs).padStart(2, '0')}`; }
            
            function useHint() { 
                if (hintsRemaining <= 0) return; 
                hintsRemaining--; hintsUsedCount++; hintsLeftElement.textContent = hintsRemaining; 
                if (!part2Started) provideHintPart1(); else provideHintPart2(); 
                if (hintsRemaining === 0) hintButton.disabled = true; 
            }
            
            function provideHintPart1() { 
                if (lockBoard) return; 
                const unmatchedCards = Array.from(memoryGameContainer.querySelectorAll('.memory-card:not(.matched):not(.flip)')); 
                if (unmatchedCards.length < 2) return; 
                const randomCard1 = unmatchedCards[Math.floor(Math.random() * unmatchedCards.length)]; 
                const pairIdToFind = randomCard1.dataset.pairId; 
                let randomCard2 = null; 
                for (const card of unmatchedCards) { if (card !== randomCard1 && card.dataset.pairId === pairIdToFind) { randomCard2 = card; break; } } 
                if (randomCard1 && randomCard2) { 
                    lockBoard = true; 
                    randomCard1.classList.add('flip'); randomCard2.classList.add('flip'); 
                    setTimeout(() => { randomCard1.classList.remove('flip'); randomCard2.classList.remove('flip'); lockBoard = false; }, 1500); 
                } 
            }
            
            function provideHintPart2() {
                 const availableWordItems = Array.from(wordItemsContainer.querySelectorAll('.word-item:not(.matched)'));
                 if (availableWordItems.length === 0) return;
                 const randomWordItem = availableWordItems[Math.floor(Math.random() * availableWordItems.length)];
                 const correctMeaning = randomWordItem.dataset.meaning;
                 const correctMeaningItem = meaningItemsContainer.querySelector(`.meaning-item[data-meaning="${correctMeaning}"]:not(.matched)`);
                 if (randomWordItem && correctMeaningItem) {
                     const originalWordBg = randomWordItem.style.backgroundColor;
                     const originalMeaningBg = correctMeaningItem.style.backgroundColor;
                     const highlightColor = '#FFF4E6'; 
                     let blinkCount = 0;
                     const blinkInterval = setInterval(() => {
                         const isHighlighted = blinkCount % 2 === 0;
                         randomWordItem.style.backgroundColor = isHighlighted ? highlightColor : originalWordBg;
                         correctMeaningItem.style.backgroundColor = isHighlighted ? highlightColor : originalMeaningBg;
                         blinkCount++;
                         if (blinkCount > 5) { 
                             clearInterval(blinkInterval); 
                             randomWordItem.style.backgroundColor = originalWordBg; 
                             correctMeaningItem.style.backgroundColor = originalMeaningBg; 
                         }
                     }, 250);
                 }
            }

            function showSummary() { part1Element.style.display = 'none'; part2Element.style.display = 'none'; summaryElement.style.display = 'block'; hintButton.style.display = 'none'; finalTimeElement.textContent = formatTime(seconds); hintsUsedElement.textContent = hintsUsedCount; }
            function goToPart2() { 
                part1Element.style.display = 'none'; part2Element.style.display = 'block'; 
                nextStage1Button.style.display = 'none'; nextPartButton.style.display = 'none'; 
                hintsRemaining = initialHints; hintsLeftElement.textContent = hintsRemaining; 
                hintButton.disabled = hintsRemaining <= 0; hintButton.style.display = 'inline-block'; 
                setupPart2(); 
            }
            function restartGame() { 
                stopGameTimer(); seconds = 0; hintsRemaining = initialHints; hintsUsedCount = 0; 
                matchedPairs = 0; part2CorrectMatches = 0; gameStarted = false; part1Completed = false; 
                part2Started = false; flippedCards = []; lockBoard = false; selectedWordItem = null; part1Stage = 1;
                timerElement.textContent = '00:00'; hintsLeftElement.textContent = hintsRemaining; 
                hintButton.disabled = false; hintButton.style.display = 'inline-block'; 
                summaryElement.style.display = 'none'; part2Element.style.display = 'none'; 
                nextStage1Button.style.display = 'none'; nextPartButton.style.display = 'none'; 
                part1Element.style.display = 'block'; setupPart1Stage(1); 
            }

            // ---- INIT ----
            hintButton.addEventListener('click', useHint);
            restartButton.addEventListener('click', restartGame);
            nextStage1Button.addEventListener('click', () => { if (part1Stage < totalPart1Stages) setupPart1Stage(part1Stage + 1); });
            nextPartButton.addEventListener('click', goToPart2);
            setupPart1Stage(1); 
            hintsLeftElement.textContent = hintsRemaining; 
            hintButton.disabled = false;
        });
    </script>
</body>
</html>

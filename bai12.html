<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tr√≤ Ch∆°i √în T·∫≠p Ti·∫øng Trung Vui Nh·ªôn ‚ú®</title>

    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.7;
            margin: 20px;
            background-color: #f0f8ff; /* Alice Blue */
            color: #333;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
        }

        #game-container {
            background: linear-gradient(135deg, #ffffff 0%, #e6f7ff 100%); /* White to light blue gradient */
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.15);
            max-width: 700px;
            width: 100%;
            text-align: center;
            border: 1px solid #b3e0ff;
        }

        h1, h2 {
            color: #0056b3;
            margin-bottom: 20px;
            font-weight: 600;
        }
        h1 { font-size: 1.8em; }
        h2 { font-size: 1.5em; }

        #welcome-screen p, #welcome-screen ul {
            font-size: 1.1em;
            margin-bottom: 15px;
        }
         #welcome-screen ul {
            list-style: none;
            padding: 0;
            text-align: left;
            display: inline-block;
        }
        #welcome-screen li { margin-bottom: 8px; }
        #welcome-screen b { color: #007bff; }

        button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 25px; /* More rounded */
            cursor: pointer;
            font-size: 1.05em;
            margin: 10px 5px;
            transition: all 0.3s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            font-weight: 500;
        }
        button:hover {
            background-color: #0056b3;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            transform: translateY(-2px);
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }

        .hint-button { /* Common style for hint buttons */
            background-color: #ffc107; /* Yellow for hint */
            color: #333;
        }
        .hint-button:hover:not(:disabled) { background-color: #e0a800; }

        #restart-button { background-color: #28a745; }
        #restart-button:hover { background-color: #218838; }

        input[type="text"] {
            padding: 12px;
            border: 1px solid #b3cde0; /* Light blue border */
            border-radius: 8px;
            margin: 10px 0 15px 0; /* More margin bottom */
            width: calc(100% - 26px);
            font-size: 1.1em;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.05);
        }
        input[type="text"]:focus {
             border-color: #007bff;
             box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.25);
             outline: none;
        }

        /* Styles for Hanzi with Pinyin using <ruby> */
        .hanzi-ruby ruby {
            display: inline-flex; /* Changed from inline-block for better spacing */
            flex-direction: column;
            align-items: center;
            margin: 0 2px; /* Adjust spacing between characters */
            line-height: 1.2; /* Adjust line height for ruby */
            font-size: 1.5em; /* Larger Hanzi */
            font-weight: 500;
        }
        .hanzi-ruby rt { /* Pinyin style */
            font-size: 0.55em; /* Pinyin smaller relative to Hanzi */
            color: #555;
            font-weight: 400;
            line-height: 1;
            user-select: none; /* Prevent selecting pinyin easily */
        }
         /* Hide ruby parentheses for browsers that don't support ruby */
        .hanzi-ruby rp { display: none; }

        #scrambled-sentence {
            background-color: #e9f5ff; /* Lighter blue background */
            padding: 15px;
            border-radius: 8px;
            font-family: 'Noto Sans SC', sans-serif; /* Good font for Chinese */
            margin-bottom: 15px;
            min-height: 50px; /* Ensure space even if empty */
            border: 1px dashed #a0d0ff;
        }

        #meaning-display {
            font-size: 1.3em;
            font-weight: bold;
            margin: 15px 0;
            color: #0069d9;
            background-color: #e7f3ff;
            padding: 10px;
            border-radius: 5px;
        }


        p.feedback { /* Common class for feedback */
            margin-top: 15px;
            font-weight: bold;
            white-space: pre-wrap;
            min-height: 20px; /* Prevent layout shift */
            padding: 10px;
            border-radius: 5px;
        }
        p.feedback.correct { color: #155724; background-color: #d4edda; border: 1px solid #c3e6cb;}
        p.feedback.incorrect { color: #721c24; background-color: #f8d7da; border: 1px solid #f5c6cb;}
        p.feedback.info { color: #004085; background-color: #cce5ff; border: 1px solid #b8daff;}


        p#attempts-left {
            color: #e67e22; /* Orange warning */
            font-size: 0.95em;
            margin-top: 5px;
        }

        .hint-display { /* Common class for hint displays */
            margin-top: 15px;
            color: #555;
            background-color: #fffbe6; /* Light yellow */
            padding: 12px;
            border-radius: 5px;
            font-style: italic;
            white-space: pre-wrap;
            text-align: left;
            border: 1px solid #ffeeba;
            min-height: 20px;
        }

        .hidden { display: none; }

        /* Timer */
        #timer-container {
            position: fixed; /* Keep timer visible */
            top: 15px;
            right: 20px;
            background-color: rgba(0, 123, 255, 0.8);
            color: white;
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 1.1em;
            font-weight: bold;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            z-index: 1000; /* Ensure it's on top */
        }

        /* Summary Table & Incorrect List */
        #summary-area { text-align: left; }
        #summary-area h2 { text-align: center; }
        table {
            width: 100%;
            margin: 20px 0;
            border-collapse: collapse;
        }
        th, td {
            border: 1px solid #cde;
            padding: 12px;
            text-align: left;
            vertical-align: top;
        }
        th {
            background-color: #007bff;
            color: white;
            text-align: center;
        }
        tbody tr:nth-child(odd) { background-color: #f8f9fa; }
        tbody tr:nth-child(even) { background-color: #e9ecef; }

        #incorrect-list { margin-top: 20px; }
        #incorrect-list h3 { color: #dc3545; margin-bottom: 10px; text-align: center; }
        #incorrect-list ul {
            list-style: none;
            padding: 0;
        }
        #incorrect-list li {
            background-color: #fff0f1; /* Light pink */
            border: 1px solid #ffdbe0;
            padding: 10px;
            margin-bottom: 8px;
            border-radius: 5px;
        }
        #incorrect-list li strong { color: #721c24; }
        #summary-total-time {
            text-align: center;
            font-size: 1.2em;
            font-weight: bold;
            margin-top: 20px;
            color: #0056b3;
        }

    </style>
    </head>
<body>

    <div id="game-container">
        <h1>Tr√≤ Ch∆°i Ti·∫øng Trung Vui Nh·ªôn ‚ú®üíñ</h1>

        <div id="timer-container" class="hidden">‚è±Ô∏è <span id="timer">00:00</span></div>

        <div id="welcome-screen">
            <p>Ch√†o m·ª´ng b·∫°n iu ƒë·∫øn v·ªõi th·ª≠ th√°ch ti·∫øng Trung nho nh·ªè!</p>
            <p>Game c√≥ 2 ph·∫ßn n√®:</p>
            <ul>
                <li><b>Ph·∫ßn 1:</b> Xem nghƒ©a ƒëo√°n ch·ªØ H√°n (c√≥ g·ª£i √Ω Pinyin nha üòâ)</li>
                <li><b>Ph·∫ßn 2:</b> X·∫øp ch·ªØ H√°n l·ªôn x·ªôn th√†nh c√¢u ƒë√∫ng (c√≥ g·ª£i √Ω nghƒ©a n√® üòé)</li>
            </ul>
             <p>S·∫µn s√†ng chinh ph·ª•c ch∆∞a n√†o? Let's gooo! üî•</p>
            <button id="start-button">B·∫Øt ƒê·∫ßu Thui!</button>
        </div>

        <div id="part1-area" class="hidden">
            <h2>Ph·∫ßn 1: ƒêo√°n Ch·ªØ H√°n ü§î</h2>
            <p id="vocab-counter"></p>
            <p><b>Nghƒ©a l√† g√¨ n√®?</b></p>
            <p id="meaning-display"></p>
            <label for="hanzi-input">G√µ ch·ªØ H√°n t∆∞∆°ng ·ª©ng v√†o ƒë√¢y nha:</label>
            <input type="text" id="hanzi-input" autocomplete="off">
            <button id="submit-part1">Ki·ªÉm Tra</button>
            <button id="hint-button-part1" class="hint-button">G·ª£i √Ω Pinyin</button>
            <p id="feedback-part1" class="feedback"></p>
            <p id="hint-display-part1" class="hint-display hidden"></p>
            <p id="attempts-left"></p>
        </div>

        <div id="part2-area" class="hidden">
            <h2>Ph·∫ßn 2: X·∫øp C√¢u Thuii üí™</h2>
            <p id="sentence-counter"></p>
            <p><b>S·∫Øp x·∫øp c√°c c·ª•m t·ª´ n√†y n√®:</b></p>
            <div id="scrambled-sentence" class="hanzi-ruby"></div> <label for="sentence-input">Vi·∫øt c√¢u ƒë√∫ng v√†o ƒë√¢y n√®:</label>
            <input type="text" id="sentence-input" autocomplete="off">
            <button id="submit-part2">Ki·ªÉm Tra</button>
            <button id="hint-button-part2" class="hint-button">G·ª£i √Ω Nghƒ©a</button>
            <p id="feedback-part2" class="feedback"></p> <p id="hint-display-part2" class="hint-display hidden"></p>
        </div>

        <div id="summary-area" class="hidden">
            <h2>üìä K·∫øt Qu·∫£ C·ªßa B·∫°n ƒê√¢yyy üéâ</h2>
            <table>
                <thead>
                    <tr>
                        <th>Ph·∫ßn ch∆°i</th>
                        <th>S·ªë l∆∞·ª£ng</th>
                        <th>S·ªë c√¢u/t·ª´ ƒë√∫ng ‚úÖ</th>
                        <th>S·ªë c√¢u/t·ª´ sai ‚ùå</th>
                        <th>G·ª£i √Ω ƒë√£ d√πng ü§î</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Ph·∫ßn 1: T·ª´ v·ª±ng</td>
                        <td id="summary-p1-total"></td>
                        <td id="summary-p1-correct"></td>
                        <td id="summary-p1-incorrect"></td>
                        <td id="summary-p1-hints"></td>
                    </tr>
                    <tr>
                        <td>Ph·∫ßn 2: S·∫Øp x·∫øp c√¢u</td>
                        <td id="summary-p2-total"></td>
                        <td id="summary-p2-correct"></td>
                        <td id="summary-p2-incorrect"></td>
                        <td id="summary-p2-hints"></td>
                    </tr>
                </tbody>
            </table>

            <div id="incorrect-list">
                 </div>

             <p id="summary-total-time">T·ªïng th·ªùi gian l√†m b√†i: ‚è±Ô∏è <span id="total-time-value"></span></p>

            <button id="restart-button">Ch∆°i L·∫°i T·ª´ ƒê·∫ßu! üöÄ</button>
        </div>
    </div>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- ** NEW DATA V3 ** ---
            const vocabData = [
                { hanzi: 'ËØ≠Ë®Ä', pinyin: 'y«î y√°n', meaning: 'ng√¥n ng·ªØ' },
                { hanzi: 'Â§ßÂ≠¶', pinyin: 'd√† xu√©', meaning: 'ƒë·∫°i h·ªçc' },
                { hanzi: 'ËØª', pinyin: 'd√∫', meaning: 'ƒë·ªçc' },
                { hanzi: 'ËßâÂæó', pinyin: 'ju√© de', meaning: 'c·∫£m th·∫•y' },
                { hanzi: 'ÊÄé‰πàÊ†∑', pinyin: 'zƒõn me y√†ng', meaning: 'th·∫ø n√†o' },
                { hanzi: 'ËØ≠Ê≥ï', pinyin: 'y«î f«é', meaning: 'ng·ªØ ph√°p' }, // Corrected pinyin
                { hanzi: 'Âê¨', pinyin: 'tƒ´ng', meaning: 'nghe' },
                { hanzi: 'ËØ¥', pinyin: 'shu≈ç', meaning: 'n√≥i' },
                { hanzi: 'ÂÜô', pinyin: 'xiƒõ', meaning: 'vi·∫øt' },
                { hanzi: 'Âíå', pinyin: 'h√©', meaning: 'v√†' },
                { hanzi: 'ÂÆπÊòì', pinyin: 'r√≥ng y√¨', meaning: 'd·ªÖ d√†ng' },
                { hanzi: '‰ΩÜÊòØ', pinyin: 'd√†n sh√¨', meaning: 'nh∆∞ng' },
                { hanzi: 'Áªô', pinyin: 'gƒõi', meaning: 'cho' },
                { hanzi: 'Êñ∞', pinyin: 'xƒ´n', meaning: 'm·ªõi' },
                { hanzi: 'Êóß', pinyin: 'ji√π', meaning: 'c≈©' },
                { hanzi: 'ÂêåÂ≠¶', pinyin: 't√≥ng xu√©', meaning: 'b·∫°n h·ªçc' },
                { hanzi: 'ÂêåÂ±ã', pinyin: 't√≥ng w≈´', meaning: 'b·∫°n c√πng ph√≤ng' },
                { hanzi: 'Áè≠', pinyin: 'bƒÅn', meaning: 'l·ªõp' },
                { hanzi: 'ÊØîËæÉ', pinyin: 'b«ê ji√†o', meaning: 't∆∞∆°ng ƒë·ªëi' }
            ];

            const sentenceData = [
                { correct: '‰Ω†‰ºöËØ¥‰ªÄ‰πàËØ≠Ë®ÄÔºü', pinyin: 'N«ê hu√¨ shu≈ç sh√©n me y«î y√°n?', scrambled: '‰ªÄ‰πà / ËØ≠Ë®Ä / ‰ºöËØ¥ / ‰Ω†', translation: 'B·∫°n c√≥ th·ªÉ n√≥i ti·∫øng g√¨?' },
                { correct: '‰Ω†Âú®Âì™‰∏™Â§ßÂ≠¶Â≠¶‰π†Ôºü', pinyin: 'N«ê z√†i n«é ge d√† xu√© xu√© x√≠?', scrambled: 'Âì™‰∏™ / Â§ßÂ≠¶ / Âú®Â≠¶‰π† / ‰Ω†', translation: 'B·∫°n h·ªçc ·ªü tr∆∞·ªùng ƒë·∫°i h·ªçc n√†o?' },
                { correct: 'ÊàëÂú®ËÉ°ÂøóÊòéÂ∏ÇÂ∏àËåÉÂ§ßÂ≠¶Â≠¶‰π†„ÄÇ', pinyin: 'W«í z√†i H√∫ zh√¨ m√≠ng sh√¨ Shƒ´ f√†n d√† xu√© xu√© x√≠.', scrambled: 'ËÉ°ÂøóÊòéÂ∏ÇÂ∏àËåÉÂ§ßÂ≠¶ / Âú®Â≠¶‰π† / Êàë', translation: 'T√¥i h·ªçc t·∫°i ƒê·∫°i h·ªçc S∆∞ ph·∫°m TP. H·ªì Ch√≠ Minh.' },
                { correct: 'ÊàëÂú®Ê∏ÖÂçéÂ§ßÂ≠¶ËØª‰π¶„ÄÇ', pinyin: 'W«í z√†i Qƒ´ng hu√° d√† xu√© d√∫ sh≈´.', scrambled: 'Ê∏ÖÂçéÂ§ßÂ≠¶ / Âú®ËØª‰π¶ / Êàë', translation: 'T√¥i h·ªçc t·∫°i ƒê·∫°i h·ªçc Thanh Hoa.' }, // Corrected pinyin/translation
                { correct: 'Ê±âËØ≠ËØ≠Ê≥ïÈöæÂêóÔºü', pinyin: 'H√†n y«î y«î f«é n√°n ma?', scrambled: 'ËØ≠Ê≥ï / ÈöæÂêó / Ê±âËØ≠', translation: 'Ng·ªØ ph√°p ti·∫øng Trung c√≥ kh√≥ kh√¥ng?' },
                { correct: '‰Ω†ÂíåÂ•πÈÉΩÊòØÊàëÁöÑÊúãÂèã„ÄÇ', pinyin: 'N«ê h√© tƒÅ d≈çu sh√¨ w«í de p√©ng you.', scrambled: '‰Ω† / Â•π / ÊúãÂèã / ÈÉΩÊòØ / Êàë / Âíå', translation: 'B·∫°n v√† c√¥ ·∫•y ƒë·ªÅu l√† b·∫°n t√¥i.' }, // Used Â•π for clarity
                { correct: 'Â≠¶Ê±âËØ≠ÂæàÂÆπÊòì„ÄÇ', pinyin: 'Xu√© H√†n y«î hƒõn r√≥ng y√¨.', scrambled: 'Âæà / ÂÆπÊòì / Â≠¶ / Ê±âËØ≠', translation: 'H·ªçc ti·∫øng Trung r·∫•t d·ªÖ.' },
                { correct: '‰ªñÂØπÊàëÂæàÂ•ΩÔºå‰ΩÜÊòØÊàë‰∏çÁà±‰ªñ„ÄÇ', pinyin: 'TƒÅ du√¨ w«í hƒõn h«éo, d√†n sh√¨ w«í b√π √†i tƒÅ.', scrambled: 'ÂæàÂ•Ω / ÂØπÊàë / ‰ªñÔºå‰ΩÜÊòØ / ‰∏çÁà± / Êàë / ‰ªñ', translation: 'Anh ·∫•y ƒë·ªëi x·ª≠ t√¥i r·∫•t t·ªët, nh∆∞ng t√¥i kh√¥ng y√™u anh ·∫•y.' }, // Adjusted translation/scrambled
                { correct: '‰∏≠ÊñáÂæàÊúâÊÑèÊÄùÔºå‰ΩÜÊòØ‰πüÂæàÈöæ„ÄÇ', pinyin: 'Zh≈çng w√©n hƒõn y«íu y√¨ si, d√†n sh√¨ yƒõ hƒõn n√°n.', scrambled: 'ÂæàÊúâÊÑèÊÄù / ‰∏≠ÊñáÔºå‰ΩÜÊòØ / ‰πüÂæàÈöæ', translation: 'Ti·∫øng Trung r·∫•t th√∫ v·ªã, nh∆∞ng c≈©ng r·∫•t kh√≥.' },
                { correct: '‰ªäÂ§©‰∏ãÂ§ßÈõ®Ôºå‰ΩÜÊòØÊàë‰ª¨ËøòÂéªÂ≠¶Ê†°„ÄÇ', pinyin: 'Jƒ´n tiƒÅn xi√† d√† y«î, d√†n sh√¨ w«í men h√°i q√π xu√© xi√†o.', scrambled: '‰ªäÂ§© / ‰∏ãÂ§ßÈõ®Ôºå‰ΩÜÊòØ / Êàë‰ª¨ / ËøòÂéª / Â≠¶Ê†°', translation: 'H√¥m nay m∆∞a l·ªõn, nh∆∞ng ch√∫ng t√¥i v·∫´n ƒëi h·ªçc.' }, // Adjusted scrambled
                { correct: 'ÊàëÊÉ≥ÂéªÈì∂Ë°åÂèñÈí±Ôºå‰ΩÜÊòØÂ∑•‰ΩúÂæàÂøô„ÄÇ', pinyin: 'W«í xi«éng q√π y√≠n h√°ng q«î qi√°n, d√†n sh√¨ g≈çng zu√≤ hƒõn m√°ng.', scrambled: 'ÊÉ≥Âéª / Èì∂Ë°å / ÂèñÈí± / ÊàëÔºå‰ΩÜÊòØ / Â∑•‰Ωú / ÂæàÂøô', translation: 'T√¥i mu·ªën ƒëi ng√¢n h√†ng r√∫t ti·ªÅn, nh∆∞ng c√¥ng vi·ªác r·∫•t b·∫≠n.' }, // Adjusted scrambled
                { correct: 'ÊàëÊÉ≥ÊâæÊàëÁöÑÂêåÂ≠¶„ÄÇ', pinyin: 'W«í xi«éng zh«éo w«í de t√≥ng xu√©.', scrambled: 'ÂêåÂ≠¶ / ÊÉ≥Êâæ / ÊàëÁöÑ', translation: 'T√¥i mu·ªën t√¨m b·∫°n h·ªçc c·ªßa t√¥i.' },
                { correct: '‰Ω†ÁöÑÂêåÂ±ãÊÄé‰πàÊ†∑Ôºü', pinyin: 'N«ê de t√≥ng w≈´ zƒõn me y√†ng?', scrambled: 'ÂêåÂ±ã / ÊÄé‰πàÊ†∑ / ‰Ω†ÁöÑ', translation: 'B·∫°n c√πng ph√≤ng c·ªßa b·∫°n th·∫ø n√†o?' },
                { correct: '‰Ω†ÁöÑÁè≠ÊúâÂ§öÂ∞ëÂêåÂ≠¶Ôºü', pinyin: 'N«ê de bƒÅn y«íu du≈ç shao t√≥ng xu√©?', scrambled: 'Áè≠ / ÊúâÂ§öÂ∞ëÂêåÂ≠¶ / ‰Ω†ÁöÑ', translation: 'L·ªõp b·∫°n c√≥ bao nhi√™u b·∫°n h·ªçc?' },
                { correct: 'Ê±âËØ≠ÊØîËæÉÈöæ„ÄÇ', pinyin: 'H√†n y«î b«ê ji√†o n√°n.', scrambled: 'ÊØîËæÉÈöæ / Ê±âËØ≠', translation: 'Ti·∫øng Trung kh√° kh√≥.' },
                { correct: '‰Ω†Âú®Âì™ÂÑøÂ≠¶‰π†Ê±âËØ≠Ôºü', pinyin: 'N«ê z√†i n«ér xu√© x√≠ H√†n y«î?', scrambled: 'Âì™ÂÑø / Âú® / Â≠¶‰π† / Ê±âËØ≠ / ‰Ω†', translation: 'B·∫°n h·ªçc ti·∫øng Trung ·ªü ƒë√¢u?' },
                { correct: '‰ªñÂú®Âì™ÂÑøÂ≠¶‰π†Ê±âËØ≠Ôºü', pinyin: 'TƒÅ z√†i n«ér xu√© x√≠ H√†n y«î?', scrambled: 'Âì™ÂÑø / Âú® / Â≠¶‰π† / Ê±âËØ≠ / ‰ªñ', translation: 'Anh ·∫•y h·ªçc ti·∫øng Trung ·ªü ƒë√¢u?' }, // Used ‰ªñ for clarity
                { correct: '‰ªñ‰ª¨ÁöÑËÄÅÂ∏àÊÄé‰πàÊ†∑Ôºü', pinyin: 'TƒÅ men de l«éo shƒ´ zƒõn me y√†ng?', scrambled: 'ËÄÅÂ∏à / ÊÄé‰πàÊ†∑ / ‰ªñ‰ª¨ÁöÑ', translation: 'Gi√°o vi√™n c·ªßa h·ªç th·∫ø n√†o?' }, // Corrected translation
                { correct: '‰ªñ‰ª¨ËßâÂæóÂ≠¶‰π†Ê±âËØ≠ÈöæÂêóÔºü', pinyin: 'TƒÅ men ju√© de xu√© x√≠ H√†n y«î n√°n ma?', scrambled: 'Â≠¶‰π† / Ê±âËØ≠ / ÈöæÂêó / ËßâÂæó / ‰ªñ‰ª¨', translation: 'H·ªç c·∫£m th·∫•y h·ªçc ti·∫øng Trung c√≥ kh√≥ kh√¥ng?' }, // Corrected translation/scrambled
                { correct: '‰Ω†‰ª¨ÁöÑËÄÅÂ∏àÊòØË∞ÅÔºü', pinyin: 'N«ê men de l«éo shƒ´ sh√¨ sh√©i?', scrambled: 'ËÄÅÂ∏à / ÊòØË∞Å / ‰Ω†‰ª¨ÁöÑ', translation: 'Gi√°o vi√™n c·ªßa c√°c b·∫°n l√† ai?' },
                { correct: 'Êñ∞ÂêåÂ≠¶Âú®Âì™‰∏™Áè≠Â≠¶‰π†Ôºü', pinyin: 'Xƒ´n t√≥ng xu√© z√†i n«é ge bƒÅn xu√© x√≠?', scrambled: 'Âì™‰∏™Áè≠ / Âú®Â≠¶‰π† / Êñ∞ÂêåÂ≠¶', translation: 'B·∫°n h·ªçc m·ªõi h·ªçc ·ªü l·ªõp n√†o?' },
                { correct: '‰ªñÁöÑËÄÅÂ∏àÊòØË∞ÅÔºü', pinyin: 'TƒÅ de l«éo shƒ´ sh√¨ sh√©i?', scrambled: 'ËÄÅÂ∏à / ÊòØË∞Å / ‰ªñÁöÑ', translation: 'Gi√°o vi√™n c·ªßa anh ·∫•y l√† ai?' }, // Used ‰ªñ for clarity
            ];
            // --- ** END NEW DATA V3 ** ---


            // --- DOM Elements ---
            const welcomeScreen = document.getElementById('welcome-screen');
            const startButton = document.getElementById('start-button');
            const restartButton = document.getElementById('restart-button');
            const timerContainer = document.getElementById('timer-container');
            const timerDisplay = document.getElementById('timer');

            const part1Area = document.getElementById('part1-area');
            const vocabCounter = document.getElementById('vocab-counter');
            const meaningDisplay = document.getElementById('meaning-display'); // Changed from image
            const hanziInput = document.getElementById('hanzi-input');
            const submitPart1 = document.getElementById('submit-part1');
            const hintButtonPart1 = document.getElementById('hint-button-part1');
            const feedbackPart1 = document.getElementById('feedback-part1');
            const hintDisplayPart1 = document.getElementById('hint-display-part1');
            const attemptsLeftDisplay = document.getElementById('attempts-left');

            const part2Area = document.getElementById('part2-area');
            const sentenceCounter = document.getElementById('sentence-counter');
            const scrambledSentenceDisplay = document.getElementById('scrambled-sentence'); // Renamed for clarity
            const sentenceInput = document.getElementById('sentence-input');
            const submitPart2 = document.getElementById('submit-part2');
            const hintButtonPart2 = document.getElementById('hint-button-part2');
            const feedbackPart2 = document.getElementById('feedback-part2');
            const hintDisplayPart2 = document.getElementById('hint-display-part2');

            const summaryArea = document.getElementById('summary-area');
            const summaryP1Total = document.getElementById('summary-p1-total');
            const summaryP1Correct = document.getElementById('summary-p1-correct');
            const summaryP1Incorrect = document.getElementById('summary-p1-incorrect');
            const summaryP1Hints = document.getElementById('summary-p1-hints');
            const summaryP2Total = document.getElementById('summary-p2-total');
            const summaryP2Correct = document.getElementById('summary-p2-correct');
            const summaryP2Incorrect = document.getElementById('summary-p2-incorrect');
            const summaryP2Hints = document.getElementById('summary-p2-hints');
            const incorrectListDiv = document.getElementById('incorrect-list');
            const totalTimeValue = document.getElementById('total-time-value');


            // --- Game State ---
            let currentPart = 0; // 0: Welcome, 1: Vocab, 2: Sentence, 3: Summary
            let currentWordIndex = 0;
            let currentSentenceIndex = 0;
            let attemptsLeft = 3;
            let scorePart1 = 0;
            let scorePart2 = 0;
            let hintsUsedPart1 = 0;
            let hintsUsedPart2 = 0;
            let shuffledVocab = [];
            let shuffledSentences = [];
            let incorrectAnswers = []; // Store details of incorrect answers
            let timerInterval;
            let startTime;


            // --- Utility Functions ---
            function shuffleArray(array) {
                let currentIndex = array.length, randomIndex;
                while (currentIndex !== 0) {
                    randomIndex = Math.floor(Math.random() * currentIndex);
                    currentIndex--;
                    [array[currentIndex], array[randomIndex]] = [array[randomIndex], array[currentIndex]];
                }
                return array;
            }

            function hideAllSections() {
                welcomeScreen.classList.add('hidden');
                part1Area.classList.add('hidden');
                part2Area.classList.add('hidden');
                summaryArea.classList.add('hidden');
                timerContainer.classList.add('hidden'); // Hide timer initially
            }

             function updateFeedback(element, message, type) {
                element.innerHTML = message.replace(/\n/g, '<br>');
                // Keep existing feedback class + add new type for styling
                element.className = 'feedback ' + type; // 'correct', 'incorrect', 'info'
            }

            // Function to create <ruby> structure for Hanzi with Pinyin
            function createRubyHTML(hanzi, pinyin) {
                // Basic split by space for pinyin - might need refinement for complex cases
                const pinyinSyllables = pinyin.trim().split(/\s+/);
                let hanziChars = hanzi.replace(/\s+/g, ''); // Remove spaces from Hanzi if any
                let html = '';
                let pinyinIndex = 0;

                // Attempt to match Hanzi characters to Pinyin syllables
                // This is a simplified approach; complex words might not align perfectly.
                for (let i = 0; i < hanziChars.length; i++) {
                    const char = hanziChars[i];
                    // Skip punctuation commonly found in sentences
                    if ("Ôºå„ÄÇÔºüÔºÅÔºõÔºö„ÄÅ,.?!;:'\"".includes(char)) {
                        html += `<span class="punctuation">${char}</span>`; // Style punctuation separately if needed
                    } else {
                         // Use the next available pinyin syllable, handle potential mismatch
                        const syllable = pinyinSyllables[pinyinIndex] || ''; // Default to empty if pinyin runs out
                        html += `<ruby>${char}<rp>(</rp><rt>${syllable}</rt><rp>)</rp></ruby>`;
                        pinyinIndex++; // Move to the next syllable
                    }
                }
                 // Add any remaining punctuation or non-ruby text if needed
                 // This part needs more robust logic if sentences contain non-Hanzi text mixed in.

                return html;
            }


            // --- Timer Functions ---
            function startTimer() {
                startTime = Date.now();
                timerContainer.classList.remove('hidden');
                timerInterval = setInterval(() => {
                    const elapsedTime = Math.floor((Date.now() - startTime) / 1000);
                    const minutes = String(Math.floor(elapsedTime / 60)).padStart(2, '0');
                    const seconds = String(elapsedTime % 60).padStart(2, '0');
                    timerDisplay.textContent = `${minutes}:${seconds}`;
                }, 1000);
            }

            function stopTimer() {
                clearInterval(timerInterval);
                 const elapsedTime = Math.floor((Date.now() - startTime) / 1000);
                 const minutes = String(Math.floor(elapsedTime / 60)).padStart(2, '0');
                 const seconds = String(elapsedTime % 60).padStart(2, '0');
                 return `${minutes}:${seconds}`; // Return formatted final time
            }

            // --- Game Logic Functions ---

            function startGame() {
                // Reset state
                currentPart = 1;
                currentWordIndex = 0;
                currentSentenceIndex = 0;
                scorePart1 = 0;
                scorePart2 = 0;
                hintsUsedPart1 = 0;
                hintsUsedPart2 = 0;
                incorrectAnswers = []; // Clear previous incorrect answers

                // Shuffle data
                shuffledVocab = shuffleArray([...vocabData]);
                shuffledSentences = shuffleArray([...sentenceData]);

                hideAllSections();
                part1Area.classList.remove('hidden');
                startTimer(); // Start the timer
                loadVocabQuestion();
            }

            // --- Part 1: Vocabulary (Meaning -> Hanzi) ---
            function loadVocabQuestion() {
                if (currentWordIndex >= shuffledVocab.length) {
                    startPart2();
                    return;
                }

                const currentWord = shuffledVocab[currentWordIndex];
                vocabCounter.textContent = `T·ª´ ${currentWordIndex + 1} / ${shuffledVocab.length}`;
                meaningDisplay.textContent = currentWord.meaning; // Show meaning
                hanziInput.value = '';
                feedbackPart1.textContent = '';
                feedbackPart1.className = 'feedback'; // Reset feedback style
                hintDisplayPart1.textContent = ''; // Clear hint
                hintDisplayPart1.classList.add('hidden'); // Hide hint
                attemptsLeft = 3;
                attemptsLeftDisplay.textContent = `S·ªë l·∫ßn ƒëo√°n c√≤n l·∫°i: ${attemptsLeft} ‚ù§Ô∏è`;
                hanziInput.disabled = false;
                submitPart1.disabled = false;
                hintButtonPart1.disabled = false; // Enable hint button
                hanziInput.focus();
            }

             function checkVocabAnswer() {
                const userAnswer = hanziInput.value.trim();
                const currentWord = shuffledVocab[currentWordIndex];
                const correctAnswer = currentWord.hanzi;

                if (!userAnswer) return;

                if (userAnswer === correctAnswer) {
                    updateFeedback(feedbackPart1, 'Chu·∫©n lu√¥n! B·∫°n gi·ªèi qu√° üëçüíØ', 'correct');
                    if (!hanziInput.disabled) { scorePart1++; } // Score only once
                    finalizePart1Question(true); // Mark as correct
                } else {
                    attemptsLeft--;
                    attemptsLeftDisplay.textContent = `S·ªë l·∫ßn ƒëo√°n c√≤n l·∫°i: ${attemptsLeft} ${attemptsLeft > 0 ? '‚ù§Ô∏è' : 'üíî'}`;
                    if (attemptsLeft > 0) {
                        updateFeedback(feedbackPart1, 'Ui, sai m·∫•t r√πi, th·ª≠ l·∫°i nha! ü§î', 'incorrect');
                        hanziInput.select();
                    } else {
                        updateFeedback(feedbackPart1, `Huhu, h·∫øt l∆∞·ª£t r√πi! üò≠ ƒê√°p √°n l√†: <span class="hanzi-ruby">${createRubyHTML(correctAnswer, currentWord.pinyin)}</span>`, 'info');
                         // Record incorrect answer
                        incorrectAnswers.push({
                            type: 'T·ª´ v·ª±ng',
                            question: currentWord.meaning,
                            correctAnswer: `${currentWord.hanzi} (${currentWord.pinyin})`
                         });
                        finalizePart1Question(false); // Mark as incorrect
                    }
                }
            }

             function showHintPart1() {
                if (currentWordIndex < shuffledVocab.length) {
                    const currentWord = shuffledVocab[currentWordIndex];
                    hintDisplayPart1.textContent = `G·ª£i √Ω Pinyin n√®: ${currentWord.pinyin}`;
                    hintDisplayPart1.classList.remove('hidden');
                    if (!hintButtonPart1.disabled) { hintsUsedPart1++; } // Count hint only once
                    hintButtonPart1.disabled = true;
                }
            }

            function finalizePart1Question(isCorrect) {
                 hanziInput.disabled = true;
                 submitPart1.disabled = true;
                 hintButtonPart1.disabled = true;
                 setTimeout(() => {
                    currentWordIndex++;
                    loadVocabQuestion();
                }, isCorrect ? 1500 : 2500); // Longer delay if incorrect to read answer
            }


            // --- Part 2: Sentence Scramble ---
            function startPart2() {
                currentPart = 2;
                hideAllSections();
                part2Area.classList.remove('hidden');
                loadSentenceQuestion();
            }

            function loadSentenceQuestion() {
                if (currentSentenceIndex >= shuffledSentences.length) {
                    showSummary();
                    return;
                }
                const currentSentence = shuffledSentences[currentSentenceIndex];
                sentenceCounter.textContent = `C√¢u ${currentSentenceIndex + 1} / ${shuffledSentences.length}`;

                // Display scrambled sentence WITH ruby pinyin
                // Need to reconstruct pinyin for scrambled parts - this is HARD.
                // **Simplification:** Show scrambled parts WITHOUT pinyin for now.
                scrambledSentenceDisplay.innerHTML = currentSentence.scrambled.replace(/\//g, ' / '); // Just show text
                // ** If pinyin mapping for scrambled parts is needed, it requires complex logic **

                sentenceInput.value = '';
                feedbackPart2.textContent = '';
                feedbackPart2.className = 'feedback';
                hintDisplayPart2.textContent = '';
                hintDisplayPart2.classList.add('hidden');
                hintButtonPart2.disabled = false;
                sentenceInput.disabled = false;
                submitPart2.disabled = false;
                sentenceInput.focus();
            }

            function checkSentenceAnswer() {
                const normalize = (str) => str.trim().replace(/[Ôºü„ÄÇÔºÅÔºå,\s]/g, ''); // Remove punctuation and spaces
                const userAnswer = normalize(sentenceInput.value);
                const currentSentence = shuffledSentences[currentSentenceIndex];
                const correctAnswer = normalize(currentSentence.correct);


                if (!userAnswer) return;

                if (userAnswer === correctAnswer) {
                     const rubyCorrect = createRubyHTML(currentSentence.correct, currentSentence.pinyin);
                     updateFeedback(feedbackPart2, `Xu·∫•t s·∫Øc! C√¢u ƒë√∫ng l√†:\n<span class="hanzi-ruby">${rubyCorrect}</span>\n<i>(Nghƒ©a: ${currentSentence.translation})</i>`, 'correct');
                     if (!sentenceInput.disabled) { scorePart2++; } // Score once
                     finalizePart2Question(true);
                } else {
                    updateFeedback(feedbackPart2, 'Opps, ch∆∞a ƒë√∫ng r√πi b·∫°n ∆°i. Ki·ªÉm tra l·∫°i ho·∫∑c d√πng g·ª£i √Ω nha! ü§î', 'incorrect');
                     sentenceInput.select();
                     // Don't record incorrect immediately, only if they move on without correcting maybe?
                     // Or record every wrong attempt? Let's record only if they finish the game without getting it right.
                     // For now, we'll record it in the summary based on score difference.
                }
            }

            function showHintPart2() {
                if (currentSentenceIndex < shuffledSentences.length) {
                    const currentSentence = shuffledSentences[currentSentenceIndex];
                    hintDisplayPart2.textContent = `G·ª£i √Ω nghƒ©a: ${currentSentence.translation}`;
                    hintDisplayPart2.classList.remove('hidden');
                    if (!hintButtonPart2.disabled) { hintsUsedPart2++; } // Count hint once
                    hintButtonPart2.disabled = true;
                 }
            }

             function finalizePart2Question(isCorrect){
                sentenceInput.disabled = true;
                submitPart2.disabled = true;
                hintButtonPart2.disabled = true;

                // If incorrect when finalizing (e.g., skipping), record it
                if (!isCorrect) {
                     const currentSentence = shuffledSentences[currentSentenceIndex];
                     incorrectAnswers.push({
                         type: 'C√¢u',
                         question: currentSentence.scrambled,
                         correctAnswer: `${currentSentence.correct} (${currentSentence.pinyin}) - ${currentSentence.translation}`
                     });
                }

                setTimeout(() => {
                    currentSentenceIndex++;
                    loadSentenceQuestion();
                }, isCorrect ? 2500 : 1500); // Delay longer if correct to read feedback
             }


            // --- Summary ---
            function showSummary() {
                currentPart = 3;
                const finalTime = stopTimer(); // Stop timer and get final time
                hideAllSections();
                summaryArea.classList.remove('hidden');

                const totalVocab = shuffledVocab.length;
                const incorrectVocab = totalVocab - scorePart1;
                const totalSentences = shuffledSentences.length;
                const incorrectSentences = totalSentences - scorePart2;

                summaryP1Total.textContent = totalVocab;
                summaryP1Correct.textContent = scorePart1;
                summaryP1Incorrect.textContent = incorrectVocab;
                summaryP1Hints.textContent = hintsUsedPart1;

                summaryP2Total.textContent = totalSentences;
                summaryP2Correct.textContent = scorePart2;
                summaryP2Incorrect.textContent = incorrectSentences;
                summaryP2Hints.textContent = hintsUsedPart2;

                totalTimeValue.textContent = finalTime;

                // Populate incorrect answers list
                incorrectListDiv.innerHTML = ''; // Clear previous list
                if (incorrectAnswers.length > 0) {
                    let listHTML = '<h3>Nh·ªØng ch·ªó c·∫ßn xem l·∫°i n√® üëÄ:</h3><ul>';
                    incorrectAnswers.forEach(item => {
                        listHTML += `<li><strong>${item.type}:</strong> ${item.question}<br>‚û°Ô∏è ƒê√°p √°n ƒë√∫ng: ${item.correctAnswer}</li>`;
                    });
                    listHTML += '</ul>';
                    incorrectListDiv.innerHTML = listHTML;
                } else {
                     incorrectListDiv.innerHTML = '<p style="text-align:center; color: green; font-weight: bold;">Wow! B·∫°n ƒë√£ tr·∫£ l·ªùi ƒë√∫ng h·∫øt! Xu·∫•t s·∫Øc! ü•≥üéâ</p>';
                }
            }


            // --- Event Listeners ---
            startButton.addEventListener('click', startGame);
            restartButton.addEventListener('click', startGame);

            // Part 1 Listeners
            submitPart1.addEventListener('click', checkVocabAnswer);
            hintButtonPart1.addEventListener('click', showHintPart1);
            hanziInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && !submitPart1.disabled) {
                    e.preventDefault();
                    checkVocabAnswer();
                }
            });

            // Part 2 Listeners
            submitPart2.addEventListener('click', checkSentenceAnswer);
            hintButtonPart2.addEventListener('click', showHintPart2);
            sentenceInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && !submitPart2.disabled) {
                    e.preventDefault();
                    checkSentenceAnswer();
                }
            });

        });
    </script>
    </body>
</html>